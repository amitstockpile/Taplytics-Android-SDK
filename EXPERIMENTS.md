Creating experiments is easy using Taplytics. You can either use our visual editor or create code-based experiments. You can find documentation on how to do this below.

| Table of Contents |
| ----------------- |
| [Dynamic Variables & Code Blocks](#dynamic-variables--code-blocks)|
| [Code Experiments](#code-experiments-deprecated) |
| [Visual Editing](#visual-editing) |
| [First-view Experiments](#delay-load) |
| [List Running Experiments](#running-experiments) |

## Dynamic Variables & Code Blocks

**To see and modify these variables or blocks on the dashboard, the app must be launched and this code containing the variable or block must be navigated to a least once.**

The code below is used to send the information of the variable or block to Taplytics, so it will appear on the dashboard.

### Dynamic Variables

Taplytics variables are dynamic variables that can be used to change content or functionality of your app dynamically from the Taplytics website. Variables are re-useable between experiments and are instantiated with three variables:

1. Variable name (String)
2. Default Value
3. TaplyticsVarListener (Optional)

The type of the variable is defined in the first diamond brackets, and must be a Parcelable type (String, Number, JSON, etc).

For example with a listener:

```java
        TaplyticsVar<Integer> var = new TaplyticsVar<>("name", 5, new TaplyticsVarListener() {
            @Override
            public void variableUpdated(Object value) {
                //Do something with the updated value
            }
        });
```

Example without a listener:

```java
		TaplyticsVar<String> stringVar = new TaplyticsVar<String>("some name","default value");
```

To retrieve the value for use, simply call `.get()`

For example:

```java
String example = stringVar.get();
```
When `.get()` is called, the value currently associated with the variable is returned. If the new value hasn't been retrieved from the server, it will fall back to the default value. 

``variableUpdated`` is called when the server does receive a new value for the variable. This should mostly be used for testing purposes, however it is available for convenience in all projects. 

### Code Blocks

Similar to Dynamic Variables, Taplytics has an option for 'Code Blocks'. Code blocks are linked to Experiments through the Taplytics website very much the same way that Dynamic Variables are, and will be executed based on the configuration of the experiment through the Taplytics website. A Code Block is a callback that can be enabled or disabled depending on the variation. If enabled, the code within the callback will be executed. If disabled, the variation will not get the callback.

A Code Block can be used alongside as many other Code Blocks as you would like to determine a combination that yields the best results. Perhaps there are three different Code Blocks on one activity. This means there could be 8 different combinations of Code Blocks being enabled / disabled on that activity if you'd like.

For example:

```java
 Taplytics.runCodeBlock("name", new CodeBlockListener() {
            @Override
            public void run() {
                //Put your code here!
            }
        });
   ```
  
By default, a code block will _not_ run unless enabled on the Taplytic Dashboard. It must be enabled for a Variation before it will run. 
   

## Code Experiments (Deprecated)

#### Setup

To set up a code-based experiment in Taplytics, please refer to the [Taplytics code-based experiment docs](https://taplytics.com/docs/guides/code-experiments).

#### Usage

Taplytics automatically generates the base needed for your code experiment. Paste it into the relevant section of your app, and apply the variables as necessary. 

It is suggested that you place the code calling the experiment in its own function (as opposed to an oncreate).

For example:

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(some_layout);
    
    // Run this code experiment. This triggers the experiment.
    runAnExperiment();
}
```
    
Then, in that function, add your experiment code generated by Taplytics, and modify it as you need.
    
```java
private void runAnExperiment(){
    Taplytics.runCodeExperiment("experiment name", new TaplyticsCodeExperimentListener() {
    
        @Override
        public void baselineVariation(Map<String, Object> variables) {
                
                        // Insert baseline variation code here.
                        Object myVar0 = variables.get("foo"); // can be null if no experiment is found
                    }
                    
        @Override
        public void experimentVariation(String variationName, Map<String, Object> variables) {
                    Object myVar0 = variables.get("foo"); // can be null if no experiment is found
                
                    if (variationName.equals("Variation 1")) {
                        // Insert Variation 1 variation code here.
                    } else if (variationName.equals("Variation 2")) {
                // Insert Variation 2 variation code here.
            }
        }
    
        @Override
        public void experimentUpdated() {
            // Use this method to re-run your code experiments when testing your experiment variations.
        }
    });
}
```

#### Previewing Code Experiments

This separate function is suggested, because if you would like to update experiments instantly for debug testing or another reason, you can simply place the `runAnExperiment()` function into the `experimentUpdated()` block.

---

## Visual Editing

You don't have to do anything else!  You can use the Taplytics dashboard to make all your visual changes. See the docs on visual editing [here](https://taplytics.com/docs/guides/visual-experiments).

---

## Delay Load

Taplytics has the option to delay the loading of your main activity while Taplytics gets initial view changes ready. Keep in mind that this initial load will only take a while the very first time, after that, these changes will be saved to disk and will not need a delay.

There are two methods to do this, **use both at the start of your oncreate after ```java setContentView()```**:

#### Delay Load With Image
In this instance, Taplytics takes care of the loading for you. Taplytics creates a splash screen with the provided image. The image will fade automatically after the given time, or when Taplytics has successfully loaded visual changes on the provided activity.

Method: ```Taplytics.delayLoad(Activity activity, Drawable image, int maxTime) ```

**Activity**: the activity (typically main activity) that will be covered in a splash image.

**Image**: A Drawable image that will be the splash screen.

**Max Time**:  Regardless of the results of Taplytics, the image will fade after this time. Milliseconds.

**Min Time**: Sometimes Taplytics loads things really fast, and this might make the image show only for a short amount of time. To keep this from happening, there is an optional minimum time option. Regardless of Taplytics loading experiments, the delayload wont finish until after this minumum time. 

**Examples**:

```java
        protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);

                Taplytics.delayLoad(this, getResources().getDrawable(R.drawable.image5), 2000);
                ...
```

**With a 1 second minimium time**

```java
                Taplytics.delayLoad(this, getResources().getDrawable(R.drawable.image5), 2000, 1000);
                ...
```

#### Delay Load with Callbacks
In this instance, Taplytics provides callbacks when the delay load should begin, and when the delay load ends. The callback will also return after the provided timeout time has been reached. This provides you the ability to show a splashscreen that is more than just a simple image. 

Method: ```Taplytics.delayLoad(int maxTime, TaplyticsDelayLoadListener listener) ```


**Max Time**: Regardless of the results of Taplytics, the image will fade after this time. Milliseconds.

**Min Time**: Sometimes Taplytics loads things really fast, and this might make the behavior of the callback undesirable. To keep this from happening, there is an optional minimum time option. Regardless of Taplytics loading experiments, the delayload wont finish until after this minumum time. 

**Listener**: This listener will provide the necessary callbacks.

**Examples**:

```java

        @Override
        protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);

                Taplytics.delayLoad(2000, new TaplyticsDelayLoadListener() {
                        @Override
                        public void startDelay() {
                                //Start delaying!
                        }

                        @Override
                        public void delayComplete() {
                                //Loading completed, or the given time has been reached. Insert your code here.
                        }
                });
                ...
                                              
```

**With a 1 second minimum time:**

```java
                Taplytics.delayLoad(2000,1000, ...

```

---

## Running Experiments

If you would like to see which variations and experiments are running on a given device, there exists a `getRunningExperimentsAndVariations(TaplyticsRunningExperimentsListener listener)` function which provides a callback with a map of the current experiments and their running variation. An example:

```java
  Taplytics.getRunningExperimentsAndVariations(new TaplyticsRunningExperimentsListener() {
                    @Override
                    public void runningExperimentsAndVariation(Map<String, String> experimentsAndVariations) {
                        //TODO: Do something with the map.
                    }
                });
```

NOTE: This function runs asynchronously, as it waits for the updated properties to load from Taplytics' servers before returning the running experiments. 

